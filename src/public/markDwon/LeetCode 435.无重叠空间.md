## LeetCode 435.无重叠空间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。


示例 1:


输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。		

------

​		这题是经典的贪心算法，只是体型新颖。其实只要想明白，[0,2]和[1,2]在对于没有[x,1]的情况下对整体结果造成的影响相同就可以清楚题解过程。将区间集合想象成一袋子拼图，区间想象成横向的 拼图背景。那我们会怎么拼呢。在正常的情况下，我们在拼图的时候，会先拼上下左右四个角，因为四个角都是圆滑的，没有凹凸，很容易分辨。

​	    这个题的道理也是一样，以实例一为例子，我们应该找下标1最小的数组为第一张拼图。为什么？因为没有比这张拼图更接近边界了，因为下标1代表拼图的右边。将拼图背景假设为0-100的一段，我们将[1,2]放入之后，下一张怎么选？先把2之前的地方剪掉，让背景变为2-100，从2开始继续找合适的边界拼图，还要考虑是否和前面已经剪掉的部分冲突，冲突就放弃。这样遍历一遍，就得出了最优解。计数放弃的部分，就得到了此题的解

用代码表示：

```js
var eraseOverlapIntervals = function(intervals) {
  let source = intervals.sort(((a, b) => {
     return a[1]-b[1]
  }))
  let start = Math.min(...intervals.flat())
  let obj = {}
  source.forEach(key=>{
    if(obj[key[1]]){
      obj[key[1]].push(key)
    }else{
      obj[key[1]] = [key]
    }
  })
  const keys = Object.keys(obj).sort((a,b)=>{return a-b})
  let i = 0
  keys.forEach((key,index)=>{
    if(index === 0){
      i++
      start = key
    }
    if(obj[key].some(item=>{return item[0] >= start})){
      i++
      start = key
    }
  })
  return intervals.length - i
};
```

